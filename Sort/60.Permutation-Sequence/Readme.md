### 060.Permutation-Sequence

首先，在nums中存储数字选项123456789。

我们令共有n位数字。假设第一个位置的数字给定了是1，那么总共有多少个这样的全排列呢？显然就是考虑第2\~N位上用数字2~N去做全排列，就是(N-1)\!个可能。同理，第一个位置如果是2的话，那么也有(N-1)\!个可能；第一个数字是3，同理也有(N-1)\!个可能……

所以，用k/(N-1)!得到的结果，就确定了第一个位置的数字。例如：假设k/(N-1)\!==4，那么就从nums里取走第4个选项nums[4]=‘5’（注意nums的起始index是0）.可以想象，形如4xxxxxxxx符合要求的全排列共有(N-1)\!\*4个，形如5xxxxxxxx符合要求的全排列共有(N-1)!\*5个，所需要的第k个一定在这两者之间。

同理，接下来考虑第二个位置的数字。注意到刚才已经排除了形如4xxxxxxxx的排列，剩下来考虑以5开头的、第k-(N-1)\!\*4个排列。如此更新k之后，要确定第二位的数字，就需要考虑第3\~N为上共有多少种可能，很明显答案是(N-2)\!.还是同样的方法，计算k/(N-2)\! 例如：假设k/(N-2)\!==4，此时需要从nums剩下的选项里取第4个，也就是6，因为第二位如果是1、2、3、4的话，连同第一位的5，所组合出的全排列共有(N-1)\!+4\*(N-2)\!，还是小于k的。（注意，第二位不可能是5，因为已经被第一位用掉了）

依次类推，确定所有位置的数字。

需要特别注意的是，最初始的k要做k--。因为上述算法中的k其实表示的是有k个其他全排列比所要求的全排列小。

