### 805.Split-Array-With-Same-Average

此题的第一个想法依然是搜索．再细细分析，这种搜索的最坏情况是需要把所有的分类情况都列举完全才能得到最后结果（比如要判定结论是false的话），那么时间复杂度就达到了o(2^N)级别，所以这是ＮＰ问题．对于ＮＰ问题的搜索解法，我们只能寄希望于高效的剪枝来减少搜索范围，但需要注意一般而言剪枝并不能从根本上改变时间复杂度．

此题的ＤＦＳ解法，可以考虑这么一个剪枝条件．先将原数组按照从大到小排列．这样将数组元素不断分配给Ａ和Ｂ两个集合的过程中，Ａ和Ｂ的平均值注定都是会下降．如果在某个时刻，Ａ的平均值大于Ｂ的平均值，而且即使把剩下未分配的元素全部都给Ａ也不能把Ａ的平均值拉低到Ｂ一样的话，我们就可以提前终止．同理，Ｂ的平均值注定大于Ａ的平均值的情况，也可以提前终止．这个剪枝方案可以通过67/87测例，但是还是ＴＬＥ．

此时我们的思路应该拐弯．虽然2^N的搜索强度很大，但注意到题目还给出了一个条件：每个元素的大小不超过１００００．这说明了什么？搜索算法是不需要考虑每个元素的大小的，此题给出这个条件就似乎暗示了什么．很显然，因为N<=30，那么所有元素加起来的总和不超过３０００００．这个数字还是稍微有点大，但总比2^30要小很多．３０００００这个数字可能是否暗示着我们可以在内存开一个这么大的数组？如果是整形的话大概会是１．２Ｇ，不算很离谱，考虑到一般情况下每个元素不会那么极限，开辟个几百兆的数组算是正常．

于是我们的思路就迅速转换到了动态规划，考虑的一个状态变量可能是sum，ＯＫ，暂且记下来．

对于ＤＰ算法，最常见的思想就是更随元素的序号i=0,1,2,...N-1逐个更新状态．假设我们已经处理了ｍ个元素，那么我们在考虑第m+1个元素时需要依据什么信息呢？显然，我们想知道前面这ｍ个元素已经是怎么分类的．对于那些已经处理了的ｍ个元素，我们势必已经做了分类，一个Ａ类，一个Ｂ类，如果知道了Ａ类的总和和数目，那么相应的Ｂ类的信息也就知道了．于是我们尝试构建状态数组dp[n][s]，其中ｎ表示当前（前ｍ个元素）Ａ类的元素数目，ｓ表示当前（前ｍ个元素）Ａ类的元素总和，于是dp[n][s]==1表示当前存在这种可能性，即A类里有n个元素总和为ｓ；反之dp[n][s]==0表示不存在这种可能性．

对于第ｍ个元素，我们就只有两种选择，一种是将其归于Ａ类，一种是将其归于Ｂ类．如果将其归为Ａ类，那么需要更新dp：即如果dp[n][s]==1的话，那么加入这个元素之后,dp[n+1][s+A[m]]也就可以为１．如果将其归为Ｂ类，那么就不需要对dp进行更新．

就这样，遍历所有m=0,1,2,...,N-1，不断更新ｄｐ．最后dp[n][s]表示将数组里的所有元素都已经完成分类之后，处于Ａ类的元素个数为n，总和为s的可能性．如果可能的话，我们很容易进一步检查是否满足Ａ类和Ｂ类的平均数相等．

因为有三重循环，这种算法的时间复杂度是 o(N*N*S)，比起o(2^N)来说很有希望pass了．
