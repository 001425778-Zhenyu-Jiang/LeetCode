### 805.Split-Array-With-Same-Average

#### 解法1: DFS
此题的第一个想法依然是搜索．也就是在这个集合里面，挑出一个真子集，使得该子集的平均值，等于targetAvg（也就是整个集合的平均数）。

这种搜索是要遍历每个元素的两种选择：是否放在这个子集中，最坏情况是需要把所有的分类情况都列举完全才能得到最后结果（比如要判定结论是false的话），那么时间复杂度就达到了o(2^N)级别，所以这是NP问题．对于NP问题的搜索解法，我们只能寄希望于高效的剪枝来减少搜索范围，但需要注意一般而言剪枝并不能从根本上改变时间复杂度．

我们将数组从小到大拍之后，能想到的这么几个优化剪枝的条件：

1. 如果当前已选择的子集元素的平均值太小，即使加上后面全部的元素也没法提升到targetAvg，可以提前退出。

2. 如果当前已选择的子集元素的平均值太大，已经超过了targetAvg，可以提前退出。

3. 如果当前idx开始有若干个连续的元素都是相等的：要么选择将这个元素加入子集中，然后递归处理下一个元素(idx+1)；要么选择不将这个元素加入子集中，然后机柜处理下一个不同的元素(A[i]!=A[idx])。

可惜结果仍然是TLE。

#### 解法2: DFS
我们考虑一个合法的真子集的元素个数是num，元素总和是sum，因为这个子集的平均数和整体的平均数相等，所以我们有
```
total/n = sum/num
```
转换一下
```
total*num = sum*n
```
可以发现{sum,num}是需要有制约关系的，而且不是任意的num都会有一个整数的sum对应。考虑到num最多也就是30个，所以这样的pair最多30个。我们尝试遍历30个这样的pair，将题目转化为：查看数组里是否能有一个真子集，元素个数是num，元素的总数是sum。

这看上去又是一个常规的DFS，而且也是o(2^n)的复杂度。DFS的过程中，我们遍历每一个元素A[idx]，有两种选择：不取它加入子集，于是递归处理下一个元素idx+1；取它加入子集，同时```num-=1```以及```sum-=A[idx]```，然后递归处理下一个元素。

搜索的截止条件有这么几个：
1. 当恰好num==0且sum==0的时候，返回true

2. 当num或者sum有任意一个先小于等于零的时候，返回false

3. idx已经处理到头了仍未满足条件，返回false.


事实上这个暴力搜索的代码跑得非常快。可能是因为上面条件2的触发概率很高。

#### 解法2: DP
我们的思路可以从另一个方向切入。虽然2^N的搜索强度很大，但注意到题目还给出了一个条件：每个元素的大小不超过10000．这说明了什么？搜索算法是不需要考虑每个元素的大小的，此题给出这个条件就似乎暗示了什么．很显然，因为N<=30，那么所有元素加起来的总和不超过30万．这个数字还是稍微有点大，但总比2^30要小很多．3e5这个数字可能是否暗示着我们可以在内存开一个这么大的数组？如果是整型的话大概会是1.2G，不算很离谱，考虑到一般情况下每个元素不会那么极限，开辟个几百兆的数组算是正常．

于是我们的思路就迅速转换到了动态规划，考虑的一个状态变量可能是sum．

对于ＤＰ算法，最常见的思想就是更随元素的序号i=0,1,2,...N-1逐个更新状态．假设我们已经处理了i-1个元素，那么我们在考虑第i个元素时需要依据什么信息呢？显然，我们想知道前面这i-1个元素是已经怎么处理（即是否加入了子集）的，他们的平均数是什么状况。这就需要记载num和sum两个变量。于是我们尝试构建状态数组```dp[num][sum]```，其中num表示某个子集的元素数目，sum表示它的元素总和。于是```dp[num][sum]==true```表示当前存在有这样一个子集：含有num个元素，总和为sum；反之```dp[num][sum]==false```表示不存在这种可能性．

对于第i个元素，我们考察：如果```dp[num-1][sum-A[i]]==true```的话，说明在第i个元素之前，存在一个子集，他的个数是num-1，和是sum-A[i]。那么加入这个元素之后,```dp[num][sum]```也就可以为true。

就这样，遍历所有i=1,2,...,N，不断更新DP．如果发现某个```DP[num][sum]```为true，并且sum/num==targetAvg，那就可以返回true。

因为有三重循环，这种算法的时间复杂度是 o(N\*N\*S)，比起o(2^N)来说很有希望pass了．
