### 805.Split-Array-With-Same-Average

#### 解法1: DFS
此题的第一个想法依然是搜索．也就是在这个集合里面，挑出一个子集，使得该子集的平均值，等于targetAvg（也就是整个集合的平均数）。

再细细分析，这种搜索是要判断每个元素是否放在这个子集中，最坏情况是需要把所有的分类情况都列举完全才能得到最后结果（比如要判定结论是false的话），那么时间复杂度就达到了o(2^N)级别，所以这是ＮＰ问题．对于ＮＰ问题的搜索解法，我们只能寄希望于高效的剪枝来减少搜索范围，但需要注意一般而言剪枝并不能从根本上改变时间复杂度．

此题的DFS解法，本质可以考虑这么一个剪枝条件．先将原数组按照从小到大排列．遍历数组元素，不断尝试是否加入集合。注意到，随着元素的加入，这个子集的平均值应该不断提高。如果到了某个元素i，我们发现当前的子集的平均数太小，即使剩下的所有元素i+1到n即使都加入这个子集的话，也不能达到targetAvg，那就可以提前终止这条路径了。

#### 解法2: DP
我们的思路可以从另一个方向切入。虽然2^N的搜索强度很大，但注意到题目还给出了一个条件：每个元素的大小不超过10000．这说明了什么？搜索算法是不需要考虑每个元素的大小的，此题给出这个条件就似乎暗示了什么．很显然，因为N<=30，那么所有元素加起来的总和不超过30万．这个数字还是稍微有点大，但总比2^30要小很多．3e5这个数字可能是否暗示着我们可以在内存开一个这么大的数组？如果是整型的话大概会是1.2G，不算很离谱，考虑到一般情况下每个元素不会那么极限，开辟个几百兆的数组算是正常．

于是我们的思路就迅速转换到了动态规划，考虑的一个状态变量可能是sum．

对于ＤＰ算法，最常见的思想就是更随元素的序号i=0,1,2,...N-1逐个更新状态．假设我们已经处理了i-1个元素，那么我们在考虑第i个元素时需要依据什么信息呢？显然，我们想知道前面这i-1个元素是已经怎么处理（即是否加入了子集）的，他们的平均数是什么状况。这就需要记载num和sum两个变量。于是我们尝试构建状态数组```dp[num][sum]```，其中num表示某个子集的元素数目，sum表示它的元素总和。于是```dp[num][sum]==true```表示当前存在有这样一个子集：含有num个元素，总和为sum；反之```dp[num][sum]==false```表示不存在这种可能性．

对于第i个元素，我们考察：如果```dp[num-1][sum-A[i]]==true```的话，说明在第i个元素之前，存在一个子集，他的个数是num-1，和是sum-A[i]。那么加入这个元素之后,```dp[num][sum]```也就可以为true。

就这样，遍历所有i=1,2,...,N，不断更新DP．如果发现某个```DP[num][sum]```为true，并且sum/num==targetAvg，那就可以返回true。

因为有三重循环，这种算法的时间复杂度是 o(N\*N\*S)，比起o(2^N)来说很有希望pass了．
