### 115.Distinct-Subsequences

此题第一眼看上去就是DFS，写出来的代码非常简洁，但是发现超时。细细一想确实会有很多重复的搜索，但如果硬要加上“记忆化”的话，本质就和DP差不多了。

DP的关键就是设计DP数组和动态转移方程。对于比较简单的DP题，就是顺着题目的要求来考虑。例如此题，要问s里的子序列包含t的个数，那么就定义dp[i][j]，表示s[0\~i]里的子序列包含t[0\~j]的个数。两个外层循环控制i和j，不断将dp[i][j]从底层往高层推进。

于是动态转移方程就比较好写了：
```cpp
        for (int i=0; i<M; i++)
         for (int j=0; j<N; j++)
         {             
             if (s[i]==t[j])
                dp[i][j]=dp[i-1][j-1]+dp[i-1][j];
             else
                dp[i][j]=dp[i-1][j];                  
         } 
```
注意，上述的两个外层循环写得比较随意，是有问题的。

首先，当i==0和j==0时，程序题内会有dp[-1]这种东西出现。所以i和j只能从1开始，这说明i==0和j==0时的初始状态要另行考虑。    
其次，j的遍历范围可以优化一下，显然j不能大于i，因为一个短字符串不可能有更长的子串。

于是改成如下：
```cpp
        for (int i=1; i<M; i++)
         for (int j=1; j<=min(i,N-1); j++)
         {             
             if (s[i]==t[j])
                dp[i][j]=dp[i-1][j-1]+dp[i-1][j];
             else
                dp[i][j]=dp[i-1][j];                  
         } 
```
那么初始状态该确定些什么呢？观察：   
当i==1的时候，随着j的遍历，会用到dp[0][0]；    
当i==2的时候，随着j的遍历，会用到dp[1][0]，dp[1][1]；   
当i==3的时候，随着j的遍历，会用到dp[2][0]，dp[2][1]，dp[2][1]；    
显然，我们要确定dp[k][0], k=0,1,2,3,...结合dp的定义，应该不难知道它们是什么:    
```cpp
        int count=0;
        for (int i=0; i<M; i++)
        {
            if (s[i]==t[0])            
                count++;
            dp[i][0]=count;                            
        }
```
最后输出的结果应该什么？结合定义，就是dp[M-1][N-1];
