### 813.Largest-Sum-of-Averages

在尝试搜索算法之前，总是要慎重考虑一下是否ＤＰ可行．特别是本题中求＂最大值＂，有着非常明显的DP的信号.

DP算法的常规动作:考虑元素的逐步递进.对于元素i而言,dp[i]和dp[i-1]有什么关系?对于元素i的处置,无非就是两种:一种就是自个儿单独做为一组;另一种就是和前面若干个元素组成一组.那么到底选择和前面多少个元素捆绑呢?枚举一下就可以了,也就是在```[1,i]```之间找到一个```j```,使得元素```[1,j-1]```组成```k-1```组的平均数之和,加上从```[j,i]```组成一组的平均数,得到最大值.

由此可见,对于```[1,i]```的DP状态是和```k-1```有关的.至此,我们可以清楚地知道,DP状态需要设计成```dp[i][k]```,表示A中前i个元素分割成k组时,能得到最大的题意要求的结果.大致的动态转移方程如下:
```cpp
dp[i][k] = dp[j-1][k-1] + sum[j:i]
```
另外可以发现,这个状态是从较小数量的分割,往较大数量的分割进行的推算.所以外层大循环是组数k,内层循环才是index.
```cpp
for (i=1; i<=N; i++)
  for (k=1; k<=min(i,K); k++)
  {
      // find the best break point j
      for (int j=i; j>=k; j--)
        dp[i][k] = max(dp[i][k], dp[j-1][k-1] + sum[j:i] );
  }
```
边界条件不难看出是k==0时的情况是未定义的,即需要提前处理所有的dp[i][0]. 通常这种边界条件是非法的（就像除数不能为零一样），为了避免涉及这个量，我们把dp[x][0]设计成最差的值，在这里就是INT_MIN.


[Leetcode Link](https://leetcode.com/problems/largest-sum-of-averages)
