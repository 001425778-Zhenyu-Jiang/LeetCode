### 940.Distinct-Subsequences-II

尝试构造状态dp[i]，表示截止第i个字符为止，我们能够创建的distinct子序列有多少．对于第i个字符ch，我们尝试思考它本身是否参与到子序列的构建中来．

情况I:如果它不参与到子序列的构建，那么dp[i-1]有多少子序列，dp[i]一定会保留全部的这些，所以```dp[i]+=dp[i-1]```

情况II:如果它参与到子序列的构建，那么dp[i-1]有多少子序列,末位加上ch之后，似乎就能生成同样多的新的子序列了．所以继续有```dp[i]+=dp[i-1]+1```．其中+1是可以让dp[i-1]额外取空．但是慢着，有一种疏漏的情况．假设dp[i-1]包含有a,aa,第i个字符是a，那么如果我们在末位加上ch的话,就得到aa,aaa．但这就和情况I（不采用当前的ch）有重复的子序列．这是因为：第i-1位不采用'a'但第i位采用'a'，等同于第i-1位采用'a'但第i位不采用'a'．所以我们需要额外减去last['a']，它表示dp[i-1]中末位是'a'的distinct子序列的个数．

所以综上，dp[i]的更新式子是:```dp[i] = dp[i-1] + (dp[i-1]+1-last[S[i])```

那么如何更新```last[S[i]]```呢？更新后的last[S[i]]表示截止到第i位，末位是S[i]的distinct子序列是多少．很简单，只要把末位置为ch，之前的数字完全等价于```dp[i-1]+1```（同理，+1是考虑可以取空的情况）
