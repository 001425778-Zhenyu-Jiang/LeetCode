### 940.Distinct-Subsequences-II

尝试构造状态dp[i]，表示截止第i个字符为止，我们能够创建的distinct子序列有多少．对于第i个字符ch，我们尝试思考它本身是否参与到子序列的构建中来．

情况I:如果它不参与到子序列的构建，那么dp[i-1]有多少子序列，dp[i]一定会保留全部的这些，所以```dp[i]+=dp[i-1]```

情况II:如果它参与到子序列的构建，那么dp[i-1]有多少子序列,末位加上S[i]之后，似乎就能生成同样多的新的子序列了．所以继续有```dp[i]+=dp[i-1]```．所以综合一下，```dp[i]=dp[i-1]*2```?

但是慢着，有一种疏漏的情况．举个例子"aaa"，考虑前两个元素的时候，可以有两种子序列"a","aa"；当考虑第三个元素的时候，不加a和加a这两种方案，会分别产生"a","aa"以及"aa","aaa"这四种方案，可以发现有重复出现了。归根结底的原因是，在考虑dp[i-1]的时候，有些子序列已经是以a结尾的，比如XXXXa；而当考虑S[i]==a的时候，如果不加这个新元素，会有之前的XXXXa，而加这个新元素，也会有新的XXXX+a，这些都是重复的，而重复的次数就是这种XXXX的个数。这个XXXX的个数怎么计算呢，那就是找在i之前出现```S[j]==S[i]```的位置，dp[j-1]就是统计了这样的XXXXa的个数！

所以综上，dp[i]的更新式子是:```dp[i] = dp[i-1]*2-dp[j-1)```其中```j```就是[1:i-1]里最后一个满足```S[j]==S[i]```的index。

另外，以上的dp[i]都包括了空subseuence的情况。最后的结果应该排除这个，即输出的是dp[N]-1.

