### 639.Decode-Ways-II

此题是和91.Decode-Ways类似的DP做法，但分情况讨论的类别更加复杂。

如果 s[i]=='0'，需要分别考虑 s[i-1]是 \*，1~2，和其他数字。
```cpp
if (s[i-1]=='*')
  dp[i]=dp[i-2]*2;  // 末两位只能是 10, 20
else if (s[i-1]=='1' || s[i-1]=='2')
  dp[i]=dp[i-2];  // 末两位可以构成一个字母
else
  return 0;
```
如果 s[i]=='1'～‘6’，需要分别考虑 s[i-1]是 \*，和其他数字。
```cpp
if (s[i-1]=='*')
  dp[i]=dp[i-2]*2+dp[i-1];  // 末两位译码的话*只能是1，2；
else
{
  int num=stoi(s.substr(i-1,2));
  if (num>=11 && num<=26)
    dp[i]=dp[i-2]+dp[i-1];  // 末两位可以译码
  else
    dp[i]=dp[i-1];          // 末两位不可以译码
}
```
如果 s[i]=='7'～‘9’，需要分别考虑 s[i-1]是\*，和其他数字。基本情况同上，只不过s[i-1]=='\*'时，\*只能是1才可以让末两位译码。
```cpp
if (s[i-1]=='*')
  dp[i]=dp[i-2]*1+dp[i-1];  // 末两位译码的话*只能是1；
else
{
  同上;
}
```
如果 s[i]=='\*'，需要分别考虑 s[i-1]是 \*，0，1，2，和其他数字。注意所有涉及\*的组合，必须用乘法。
```cpp
if (s[i-1]=='*')
  dp[i]=dp[i-2]*15+dp[i-1]*9; // 末两位译码时，**只能代表11~19,21~26共15个可能。
else if (s[i-1]=='0')
  dp[i]=dp[i-1]*9;
else if (s[i-1]=='1')
  dp[i]=dp[i-2]*9+dp[i-1]*9;
else if (s[i-1]=='2')
  dp[i]=dp[i-2]*6+dp[i-1]*9;
else
  dp[i]=dp[i-1]*9;  
```
