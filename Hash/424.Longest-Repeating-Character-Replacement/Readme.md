### 424.Longest-Repeating-Character-Replacement
本题的本质就是用一个滑动窗口，查找最长的sub array，使得其最多含有ｋ-1个与majority不相同的字符．这里ｍａｊｏｒｉｔｙ指的是窗口中出现最多的那个字符．

很显然，我们需要一个hash map或者字典来存放每个字符出现的次数．在不断拓宽窗口的过程中，如果```窗口长度数M - majority元素的个数N > K```，那么就需要移动左指针缩短窗口．为什么呢？因为如果只移动右指针，即使加入了majority元素，窗口内的那些非majority元素仍然多于Ｋ，使得整体无法成为一个合法的窗口．

那怎么计算majority元素的个数Ｎ呢？最笨的方法是遍历当前的字典，查找最大的value．比较聪明的方法是，只要观察最新引进的那个字符就行．如果新引进的字符对应的ｖａｌｕｅ大于了记录中的Ｎ，那么就更新Ｎ；否则Ｎ就不需要更新．

补充分析：
１．　为什么移动左指针的时候不修正maxNum，也就是majority number的数目？因为每次移动左指针的时候，只移动一步，所以在下一个循环的初始,maxNum = max(maxNum, Map[s[j]])就起到了更新的作用．
