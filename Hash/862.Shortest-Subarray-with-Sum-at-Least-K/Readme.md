### 862.Shortest-Subarray-with-Sum-at-Least-K

遇到continous subarray的题目,最常用的策略就是构建累加和preSum数组.这样,此题就转化为在preSum中找到两个间距最短的位置j和i,使得```preSum[j]-preSum[i]>=K```.对于这种题,通常我们会遍历i,然后在每个i之前的index查找满足条件的最小j.

对于此类问题,我们会把所有经历过的preSum都存在一个有序集合里.这里我们使用map,记录曾经出现过的preSum以及它对应的在数组中的index.注意到如果遇到相同的preSum,后加入的index会覆盖先前的值,这是合理的:因为对于任何preSum我们恰需要更新的,较大的index来保持[j,i]之间的距离最短.

假设我们考虑某个i,那么在i之前出现的所有preSum都已经在map里.此时如果map里所有键小于```preSum[i]-K```的preSum都是符合要求的.我们只要遍历这些键对应的值(也就是index),找到最大的那个就是距离i最近的j.

这样的算法仍然会超时,主要是因为上面遍历键值的过程花时间.怎么优化呢?

我们每次在将```{preSum[i],i}```插入map时,插入的可能是map中间的某个位置.我们发现,此时所有大于perSum[i]的键都是没有意义的,因为你preSum[i]带来了当前最新(也是最大)的值i.举个例子,如果此时目标键为k且k>preSum[i],那么在map中搜索所有小于等于k的"键"并且找它们之中最大的"值",得到的结果必然是i.所以每个回合里,我们插入```{preSum[i],i}```之后,可以将map从后往前不断删除元素,直至遇到preSum[i]为止,这样可以使得map始终保持精简.

上面这个操作会带来一个意想不到的好处!那就是如果目标键为k,那么我们不需要找在map里遍历所有小于等于```preSum[i]-K```的所有键,因为这些"键"对应的最大"值"就存在于离```preSum[i]-K```最近的那个键里面.原因就如上段所述.

所以每个回合的过程可以总结为:
```
1.在map里找到小于并且离preSum[i]-K最近的那个键,其值就是所需的满足条件的最大j
2.在map里插入{preSum[i],i}
3.在map删除所有大于preSum[i]的键
```
