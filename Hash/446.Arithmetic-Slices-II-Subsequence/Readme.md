### 446.Arithmetic-Slices-II-Subsequence

#### 解法1

首先我们会想，如何能够确定一个等差数列．知道了首项，公差，就能往后推序列的其他元素．所以本题容易想到的一个思路就是正向地搜索．这样的话，光遍历首项和公差就是o(N^2)的复杂度，后续的DFS更是计算量巨大．

搜索不成的话，DP是个很常规的替代方案．考虑到本题是求方案的数量，所以DP解法的嫌疑就更大了．最常见的DP套路，就是考察待求的状态量```DP[i]```与之前的状态量```DP[j]```之间的推导关系，这里的```DP[i]```不妨就设计为题意要求的以元素```j```结尾的的等差数列的个数．

如果```i```是等差数列的最后一个，那么它之前的一个元素是什么呢？那么```j=0~i-1```都是有可能的，只要元素```j```是某个相同公差的等差数列的结尾元素．如果是的话，显然```DP[i]+=DP[j]```．由此，我们看到一个重要的因素，那就是公差```diff```．也就是说，判断```j```是否和```i```构成等差数列的条件，就是先计算```diff=A[j]-A[i]```，然后再考察```j```是否为一个公差为```diff```的等差数列的尾项．于是我们还需要在DP数组中给Ａ的每个元素开辟一个Hash，用来存储它所涉及的公差．

核心代码如下：
```cpp
vector<unorderd_map<int,int>>DP(N);
for j= 0 to i-1
{
  diff = A[i]-A[j];
  DP[i][diff] += DP[j][diff];
}
```
#### 解法2

一个等差数列,可以通过后两位元素就能唯一确定.所以另一个很常见的DP解法,就是定义状态变量DP[i][j]表示为以元素i,j结尾的等差数列的个数.

我们通过i,j,查找之前是否存在一个索引k使得```A[i]*2=A[k]+A[j]```.如果找到的话那就说明```DP[i][j]+=DP[k][i]+1```。其中```DP[k][i]+1```的意思是：以i,j为结尾的等差数列，大部分可以由以k,i为结尾的等差数列延长而来（多加上一个A[i]而已），但还多出来的一个就是仅含有k,i,j三个元素的等差数列。另外，这里为什么是```+=```而不是```=```，那是因为这样的k可能会有好几个(对应相同的A[k]值).

想通过A[k]值找到k,需要提前处理,用到一个一对应多的hash表unordered_map<int,vector<int>>Map.


[Leetcode Link](https://leetcode.com/problems/arithmetic-slices-ii-subsequence)