### 446.Arithmetic-Slices-II-Subsequence

首先我们会想，如何能够确定一个等差数列．知道了首项，公差，就能往后推序列的其他元素．所以本题容易想到的一个思路就是正向地搜索．这样的话，光遍历首项和公差就是o(N^2)的复杂度，后续的ＤＦＳ更是计算量巨大．

搜索不成的话，ＤＰ是个很常规的替代方案．考虑到本题是求方案的数量，所以ＤＰ解法的嫌疑就更大了．最常见的ＤＰ套路，就是考察待求的状态量```DP[i]```与之前的状态量```DP[j]```之间的推导关系，这里的```DP[i]```不妨就设计为题意要求的以元素```j```结尾的的等差数列的个数．

如果```i```是等差数列的最后一个，那么它之前的一个元素是什么呢？那么```j=0~i-1```都是有可能的，只要元素```j```是某个相同公差的等差数列的结尾元素．如果是的话，显然```DP[i]+=DP[j]```．由此，我们看到一个重要的因素，那就是公差```ｄｉｆｆ```．也就是说，判断```j```是否和```i```构成等差数列的条件，就是先计算```diff=A[j]-A[i]```，然后再考察```j```是否为一个公差为```diff```的等差数列的尾项．于是我们还需要在ＤＰ数组中给Ａ的每个元素开辟一个Ｈａｓｈ，用来存储它所涉及的公差．

核心代码如下：
```cpp
vector<unorderd_map<int,int>>DP(N);
for j= 0 to i-1
{
  diff = A[i]-A[j];
  DP[i][diff] += DP[j][diff];
}
```
