### 964.Least-Operators-to-Express-Number

这道题还是很有难度的。

首先我们要厘清本题的实质。根据四则混合运算的性质，我们可以将一串表达式看成是若干个乘除项的加减。对于所有的乘除项，其实无非就是那么几种：```x/x```,```x```,```x*x```,```x*x*x```,...其他的都不可能。为什么呢？首先，类似于```x*x/x*x**x/x/x```这种乘除混搭的形式，明显可以合并精简，这样设计显然浪费了操作。其次，类似于```x/x/x/x/x```这种除法操作多于乘法操作的形式，得到的结果一定是小数，如果整个表达式里包含了小数项，那么无论怎么操作都不可能得到最终target为整数的答案。

所以综上，本题的目的其实就是将target写成 ```a0*x^0 + a1*x^1 + a2*x^2 + ... ak*x^k```的形式，要使得总操作符的数目最小。其中```a0,a1,a2,...,ak```都是整系数，但是可正可负。

我们容易知道，如果想要得到```3*x^4```,就是写成```+x*x*x*x+x*x*x*x+x*x*x*x```的形式，需要```3*4=12```个操作符（包括队首的那个正号）。如果想要得到```2*x^5```,就是写成```+x*x*x*x*x+x*x*x*x*x```的形式，需要```2*5=10```个操作符（因为要包括每个乘除项队首的那个正号）。总的来说，要得到```ai*x^i```，需要用到```ai*i```个操作符。唯一例外的就是i==0的时候，我们要得到一个```x^0```，反而需要两个字符+x/x。

OK，有了以上的铺垫，那么我们进入正题：如何确定ak呢？上面的分解形式```target = a0*x^0 + a1*x^1 + a2*x^2 + ... ak*x^k```，这与把一个数进行x进制分解何其相似。于是，我们应该想到会不会 ```ak = target / x^k```，确定了ak之后，我们可以得到剩下的部分 ```remainder = target - ak*x^k```，而这部分的最高次只能是k-1. 于是，递归的算法 ```helper(remainder,k-1)``` 就呼之欲出了。

显然，以上想法得到的是一个固定的分解方式，因为这种方法我们强制使得所有的```ai>0```。我们还可以怎么做呢？我们还可以尝试x^k的系数设置为(ak+1)，这样我们多出了```remainder = (ak+1)*x^k-target```这部分，没关系，我们依然可以一样递归处理，即处理 ```helper(remainder,k-1)```即可，只不过得到的a_(k-1)需要反个符号就行了。

所以，我们可以设计递归函数 helper(target,k)，确定ak的系数（有两种方案，分别是```a_k1 = target/x^k```, ```a_k2=a_k1+1```），然后剩下的部分继续调用 helper(remainder,k-1)，直至```k==0```为止。

最大的k是什么呢？注意应该是```(int)log(target)/log(x)+1```。也就是说x^k完全可能比target还大。比如 ```helper(75,11)```的最佳方案就是 ```1*11^2 - 4*11^1 - 2*x^0```.

另外，我们需要记忆化手段记录每次得到的```helper(target,k)```以缩短递归时间。

还有，最终答案要减去1，这是因为第一个乘除项的队首其实不需要正号。
