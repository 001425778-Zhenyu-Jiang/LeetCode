### 630.Course-Schedule-III

本题本质是贪心法，需要人工设计出最优策略。应用层面上用到了数组排序+PQ的组合，很像502.IPO，但是本题的最优策略要独立思考出来更有难度。

将courses按照结束时间的先后排序。构造一个大顶堆的priority_queue，整型变量day（初始为0）记录修完pq里面收录的课程所花的总时间。

遍历courses，假设当前课程为c。如果day+c[0]<=c[1]，则说明可将此课程加入且不会超过截止日期，放心地将c[0]加入队列。

如果day+c[0]>c[1]，则说明此课程不可直接加入否则会超时，那么怎么办呢？我们尝试拿出此时队列里耗时最多的那门课（即pq的堆顶）与当前的这门课交换，即退掉堆顶的课程、加入c这门课。如果pq.top()>c[0]，说明交换以后肯定能容下c这门课，此时总课程数目不变、不会超过新的截止日期，更反而额外挤出了一段时间。交换之后，新的day=day-q.top()+c[0]变得更小了.而如果pq.top()<=c[0]，说明什么呢？不确定！即使交换之后day-q.top()+c[0]<c[1]，虽可以保持总课程数不变，但有可能反而挤压了冗余时间，总的来说并没有更赚。

编程中一个可能的误区是：当day+c[0]>c[1]时，考察day-q.top()+c[0]<c[1]作为判断是否交换的条件。如上所述，这会有风险、并不是最优的策略。
