### 310.Minimum-Height-Trees

本题表面上是关于图、关于树，本质上我觉得更像BFS，或者说树的level order traversal.

本题的意思是，想从一棵树的一群nodes里找出一个node作为根，使得从这个根节点出发，发散到周围的叶子节点的路径范围最短。可以想见，这个根节点必然得尽可能地位于“中央”。如何确定“中央”的位置呢？我们其实可以反其道而行之，从“边疆”出发往内地进军。从所有的叶子节点（入度为1、出度为0）同步出发，一步一步地往前走，那么它们的最终汇合点，必然就是最“中央”的地方。

很明显，这就是一棵树的层级遍历 (level order tranversal)。传统的树操作都是从root开始的（因为通常只给你一个root），必须从顶往底用队列的结构一层一层遍历。但这里给出了图的表述，这样我们就可以轻易地找出哪些是最底端的叶子节点，从叶子节点反推上去。

具体的算法是：

1. 构造candidates的集合，里面包含了0~n-1所有的节点。
2. 根据图结构从candidates里面找出所有的叶子节点，放在temp数组里。判据就是这些叶子节点只有一个edge。
3. 遍历temp数组，将这些叶子节点移出candidates集合；并且将这些叶子节点所对应的上级节点，在图结构砍去和这些叶子节点的通路。这样，下一个汇合遍历的时候，那些上级节点就会成为新的叶子节点。
4. 重复2，直到candiates集合只剩一个或两个元素，就是最终答案。

注意：为什么最后会有一个或两个元素可以作为答案。我也是看网上参考才知道的。不过这也非常好理解。如果最后还剩下三个连通的节点（因为这是一棵树，必然彼此连通），显然还有从两边“往中央进军”的余地，必然只有一个是中央；如果最后还剩下两个连通的节点，两边各进一步的话就僵持住了，显然可以是并列的“中央”
