### 765.Couples-Holding-Hands

此题可以人工找到最优的策略,所以属于贪心法.

考虑这么一个字串```03....61....42....```.我们试图想把前两个数字变为```01```使得配成一对,那么最高效的方法就只有把3和1进行交换.于是得到```01....63....42....```接下来,为了充分利用刚才的这次交换,我们可以假定3已经处于了最终位置,那么我们需要把6换掉变成2,使得```23```配成一对.于是得到```01....23....46....```接下来,同理,为了充分利用刚才的这次交换,我们固定4的位置,需要把6换走,换来5,...以此类推,直到某次交换结束后恰好配成了一对不需要再做这样的换走/换来的swap.这其实说明这M次swap形成了一个闭环,共配成了M+1对,是最高效的方法.

接下来,我们可以继续在这个数列里寻找下一个没配对的位置,重复上述的过程,在一个闭环中完成若干次匹配.这种算法可以成为```cyclic swapping```

以上述例子的第二次swap为例,核心的代码如下:
```cpp
while (flag==0)
{
  // 此时序列是```03....61....42....```,partner是1,curPos是1
  
  swap(row[curPos],row[Pos[partner]]);  // 交换3和1,得到```01....63....42....```
  
  holder = row[Pos[partner]]; // holder是在当前配对中已经固定好的那个数,即3
  int holder_pos = Pos[partner];  // holder所在的idx,即此时3的那个位置
  
  partner = coupleID[holder]*2==holder? holder+1:holder-1;  //根据holder,确定它的partner,即2
  curPos = (holder_pos%2==0) ? holder_pos+1:holder_pos-1;   //根据holder_pos,确定下次需要交换的两个数的其中一个位置,即此时3前面的那个位置
  
  flag = row[curPos]==partner; //判断此时holder和partner是否已经配对,否则需要继续循环
}
```
