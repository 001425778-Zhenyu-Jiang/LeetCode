### 1392.Longest-Happy-Prefix

这道题所求的东西其实就是KMP算法中的一个重要的步骤，称为求后缀数组。我们先来回顾一下后缀数组在KMP中的应用。

我们令长字符串为s，目标字符串为t。后缀数组suffix[j]指的是：对于目标串的字符t[j]，以其为尾字符的一个最长后缀子串，满足同时是t的前缀。也就是说，suffix[j]==k的话，那么t[0:k-1]==t[j-k+1:j]。注意，这里的k可以是零。

下面举个例子。我们在如下的位置尝试将t[0]与s[i-4]对齐进行匹配。结果发现最多只能匹配到t[4]==s[i]，当查到t[5]!=s[i+1]时匹配失败。
```
          i
s:bacbababaabcbab
      |||||
t:    abababca
      012345
```    
这时候是否意味着我们只能将t[0]重新与s[i-3]对齐然后再匹配呢？其实不用。我们如果查到suffix[4]=3的话（结合上面的定义，这个前缀与后缀的共同子串就是"aba"），我们知道s[i-2:i]==t[0:2]，于是下一步我们可以直接将s[i-2]和t[0]对齐，而且这个对齐必定能保证3个字符的匹配，意味着下一次我们只要查看s[i+1]是否和t[3]相等就行了。（见下图）
```
          i
s:bacbababaabcbab
        |||
t:      abababca
        012345
```    
总结一下，我们从s[i+1]!=t[j+1]时的匹配失败，可以跳转的下一步是检查s[i+1]是否能和t[suffix[j]]匹配，而不必重头检查s的下一个字符与t[0]开始匹配。这中间优化的一步就是充分利用了后缀数组的作用：已知当前s[i-j:i]==t[0:j]，而且t[j]结尾的长度为k（即suffix[j]）的子串恰好是t的前缀，所以我们立即得知s[i-k+1:i]（即以s[i]为结尾的长度为k的子串）与t[0:k-1]（即t的长度为k的前缀串）已经是匹配的了。







