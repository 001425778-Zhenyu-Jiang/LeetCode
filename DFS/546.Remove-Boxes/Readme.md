### 546.Remove-Boxes

此题很难，能在短时间内独立思考出来的都算是大牛了。网上对于此题的大多数解法都是ＤＦＳ＋记忆化，但保存的是一个状态数组，这一点和ＤＰ非常相似，

此题第一眼看上去，确实有点像ＤＰ的意思。假设```dp[l][r]```表示从第```ｌ```个元素开始、到第```ｒ```个元素结束的这些盒子，进行某些操作能得到的（令全局）最优的结果。那么这样的```dp[l][r]```会是什么呢？

假设有这么一个片段```ＢＡＡＡＢＸＸ```,索引```l```和```ｒ```表示两个Ｂ的位置。如果```XX```代表了一个Ｂ，那么最佳策略是：先合并中间的Ａ，再合并剩下的Ｂ，共得分3^2+3^2。但如果```XX```代表了```ＢＢ```，那么最佳策略应该是：先合并后边的Ｂ，再合并中间的Ａ，再合并剩下的Ｂ，共得分3^2+3^2+1^2

这说明了什么？说明```dp[l][r]```中的两个参数并不足以确定这个区间内的最优操作，它还和这个区间后与```boxes[ｒ]```相同的元素```XXX```的数目有关。注意，这个```ＸＸ```并不一定是原本就紧贴着```[l,r]```区段存在的，可能是其他区段进行了某些消除操作之后剩余的。

所以我们重新定义状态数组```dp[l][r][k]```，表示区间```[l,r]```并且在这个区间后跟着ｋ个与boxes[ｒ]相同的元素，此种情况下进行消除操作能得到的最高分。

这个```dp[l][r][k]```如何往下转移呢？

首先的一个方案，可以将后段的那k+1个相同元素直接抹去，于是转化 ```dp[l][r-1][0]+(k+1)^2```

第二个方案，如果在```[l,r]```区间内有个```i```使得```boxes[i]==boxes[r]```，那么可以```boxes[i]```作为分界点断开```[l,r]```区间，区间后半部分```[i+1,r-1]```先行消除干净，于是状态转化为　```dp[l][i][k+1] + dp[i+1][r-1][0]```

因此```dp[l][r][k]```的最优解就是以上方案中的最大值。

最后的结果是输出```dp[0][N-1][0]```


[Leetcode Link](https://leetcode.com/problems/remove-boxes)
